> 2022.12.11

  

# Glib库相关

  

## 简介

  

- Glib库是一个用于开发C语言应用程序的库，它提供了许多有用的基础功能，例如数据结构、字符串处理、跨平台支持等。

- Glib是一个跨平台的库，可用于开发各种不同类型的应用程序，包括桌面应用程序、服务器程序和嵌入式系统。

- Glib通常与GTK+一起使用，用于开发图形用户界面（GUI）应用程序。

  

## 安装

  

### 安装MacPorts

  

MacPorts是一个开源软件项目，旨在为macOS系统提供一个开发工具集，用于安装、管理和卸载软件包。它使用类似于Linux系统中的apt-get或yum命令行工具，通过一个名为Portfile的文件描述每个软件包的安装方式，并自动下载、编译和安装所需的软件包。

  

MacPorts主要用于开发人员和其他技术人员，可以用它来安装一些常用的开发工具，例如GCC、Clang、Python、Perl、Ruby等，也可以用它来安装一些常用的库和框架，例如GLib、GTK+、Qt、wxWidgets等。

  

要安装MacPorts，首先需要在您的macOS系统上安装Xcode或Xcode Command Line Tools，这些工具是macOS开发所必需的。然后，打开浏览器，访问https://www.macports.org/install.php

并下载最新版本的MacPorts安装包。下载完成后，双击安装包，按照提示完成安装。安装完成后，您可以在终端中使用`port`命令来管理软件包。例如:

- 要查找一个软件包，可以运行以下命令：`port search <package-name>`

- 要安装一个软件包，可以运行以下命令：`sudo port install <package-name>`

- 要卸载一个软件包，可以运行以下命令：`sudo port uninstall <package-name>`

这些命令可以帮助我们使用MacPorts管理macOS系统上的软件包。

> 安装软件包时，需要使用sudo来提升权限，因为MacPorts需要写入系统目录。

  

如果想了解更多关于MacPorts的信息，可以在终端中输入man port来查看MacPorts的使用说明，或者访问https://www.macports.org 来获取更多相关信息。

  

### 配置MacPorts

  

- `vim .zshrc`

- `export PATH="/opt/local/bin:$PATH"`

- `source ~/.zshrc`

  

### 安装glib库

  

`sudo port install glib2`

  

还需要配置环境变量.zshrc，.vimrc，.ycmconfig。

  

## 定时器g_timeout_add()

  

g_timeout_add是一个用于添加定时器事件的函数，它可以在指定的时间后调用指定的回调函数。

函数原型：`guint g_timeout_add(guint interval, GSourceFunc function, gpointer data);`

- 参数1 interval：表示多长时间后调用回调函数，单位是毫秒。

- 参数2 function：是回调函数的名称。

- 参数3 data：是传递给回调函数的参数。

- ret：这个函数返回一个整数类型的标志符，用于识别这个定时器。

  

### sample

```cpp

#include <glib.h>

#include <iostream>

  

// 定义定时器回调函数

gboolean timer_callback(gpointer data)

{

printf("Hello, World!\n");

return G_SOURCE_CONTINUE; // 继续定时器

}

  

int main()

{

GMainLoop *loop = g_main_loop_new(NULL, FALSE);

// 设置定时器，每隔1秒调用一次timer_callback函数

g_timeout_add(1000, timer_callback, NULL);

g_main_loop_run(loop);

g_main_loop_unref(loop);

return 0;

}

```

其中，g_main_loop_unref是一个用于释放GMainLoop对象的函数。

在GLib中，GMainLoop对象用于管理事件循环，通常用于在应用程序中处理定时器、IO事件和其他事件。

在上面的示例中，我们创建了一个GMainLoop对象，并使用它来运行定时器。

在应用程序退出时，我们需要调用g_main_loop_unref来释放这个对象，以便释放它占用的内存。

  

但是需要注意，在调用g_main_loop_unref时，需要确保事件循环已经停止运行。如果事件循环仍然在运行，则g_main_loop_unref函数将不会执行任何操作。

  

```shell

# Makefile

  

```

  

### g_timeout_add的回调函数

  

回调函数的返回值为bool类型是因为其作用是指定定时器是否应该继续运行。

如果回调函数返回true，则定时器会继续运行，并在下一次超时时调用回调函数。

如果回调函数返回false，则定时器会停止运行，并不再调用回调函数。

  

当满足某些条件的时候，返回false，可以退出定时器。sample如下：

```cpp

bool timer_callback(gpointer user_data)

{

// do something

if (should_stop)

return false;

return true;

}

```

  

### g_timeout_add的返回值

  

g_timeout_add函数返回一个整型值，表示添加的定时器的ID。

我们可以使用这个ID来控制定时器的运行情况。最后使用g_source_remove函数来删除指定ID的定时器，从而停止定时器的运行。

  

如果回调函数返回`G_SOURCE_REMOVE`,则g_timeout_add函数返回0，表示该定时器已经移除。

如果回调函数返回`G_SOURCE_CONTINUE`,则g_timeout_add函数返回一个非0值，表示源仍然存在。

  

```cpp

guint id = g_timeout_add(1000,timer_callback,NULL);

if(id == 0){

//表示回调函数已被移除

}else{

//表示回调函数仍然存在

}

```

通过检查g_timeout_add函数的返回值，可以确定回调函数是否已经被移除，我们可以作出相应的处理。

  

### g_timeout_add的应用

  

在service中，我们经常要向server去请求数据，但是时常会遇到一些问题，如网络问题等，我们并不能取到正确的数据，对于出错的情况我们要做好出错处理。

1. 打出log，提示错误信息

2. retry重新获取

此时，我们就可以用g_timeout_add这个定时器去帮我们完成这样一件事。在回调函数中，如果获取到正确的数据，则返回false不再调用定时器，如果没能取到数据，则返回true，等待定时器设置的时间间隔，继续重新请求，直至取到正确的数据。

  

```c++

//Foo.h

class Foo{

public:

Foo();

~Foo();

  

void Connect();

void ReConnect();

private:

static gboolean retry_connect_cb(gpointer data);

private:

guint retryTimerId;

}

```

  

```c++

//Foo.cpp

#define RETRY_CONNECT_TIME 3000

  

Foo::Foo():retryTimerId(0){}

  

Foo::~Foo(){

if(retryTimerId > 0){

g_source_remove(retryTimerId);

retryTimerId = 0;

}

}

  

void Foo::Connect(){

int success = doSomething();

if(!success){

ReConnect();

}

}

  

void Foo::ReConnect(){

if (retryTimerId > 0){

g_source_remove(m_RetryiTimerId);

}

  

retryTimerId = g_timeout_add(RETRY_CONNECT_TIME, Foo::retry_connect_cb, NULL);

if (retryTimerId == 0){

cout<<"g_timeout_add return 0, need not start timer"<<endl;

}

}

  

gboolean Foo::retry_connect_cb(gpointer data)

{

int success = doSomething();

if(success){

cout<<"success,exit timer"<<endl;

retryTimerId = 0;

return false;//返回false表示不需要再循环了

}else{

cout<<"fail,try next time"<<endl;

return true;//继续循环

}

}

```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjA3ODU1NDI0XX0=
-->