> 2022.9.22

  

# c++拷贝文件

  

## 方式一 使用fwrite和fread

  

```c++

int copy_file(const string &from, const string &to, Json::Value &rsp)

{

FILE* fSrc = fopen(from.c_str(),"rb");

if (NULL == fSrc)

{

_ERR("failed to open: %s, error reason: %s", from.c_str(),strerror(errno));

rsp["reason"] = "failed to open the file";

return -1;

}

FILE* fDes = fopen(to.c_str(), "wb");

if (NULL == fDes)

{

_ERR("failed to create file: %s,error reason: %s", to.c_str(),strerror(errno));

rsp["reason"] = "failed to create the file";

return -1;

}

unsigned char* buf;

unsigned int length;

fseek(fSrc, 0, SEEK_END);

length = ftell(fSrc);

buf = new unsigned char[length+1];

memset(buf, 0, length+1);

fseek(fSrc, 0, SEEK_SET);

fread(buf, length, 1, fSrc);

fwrite(buf, length, 1, fDes);

_INFO("result: [%s]", buf);

rsp["output"] = buf;

fclose(fSrc);

fclose(fDes);

delete [] buf;

return 0;

}

```

  

## 方式二 使用popen(shell命令方式) 更简单

  

```c++

int copy_file(const string &from, const string &to, Json::Value &rsp)

{

string command = "cp";

command += " ";

command += from;

command += " ";

command += to;

_INFO("command is [%s]", command.c_str());

FILE *fp = popen(command.c_str(), "r");

if (NULL == fp)

{

_ERR("failed to execute command: [%s]", command.c_str());

rsp["reason"] = "failed to copy file";

return -1;

}

else

{

char result[1024];

memset(result, 0, 1024);

fread(result, 1, 1024, fp);

_INFO("result: [%s]", result);

rsp["output"] = result;

pclose(fp);

}

}

```

  

### 方式三 循环读取文件拷贝

  

```c++

const static int COPY_BUFFER_LENGTH = 16 * 1024 * 1024;

int copy_file(const string &from, const string &to, Json::Value &rsp)

{

FILE *fSrc = fopen(from.c_str(), "rb");

if (NULL == fSrc)

{

_ERR("failed to open: %s, error reason: %s", from.c_str(), strerror(errno));

rsp["reason"] = strerror(errno);

return -1;

}

  

struct stat st;

fstat(fileno(fSrc), &st);

unsigned long fileSize = (unsigned long)st.st_size;

_INFO("fileSize: %lu", fileSize);

  

FILE *fDes = fopen(to.c_str(), "wb");

if (NULL == fDes)

{

_ERR("failed to create file: %s,error reason: %s", to.c_str(), strerror(errno));

rsp["reason"] = strerror(errno);

fclose(fSrc);

return -1;

}

  

unsigned char *buf = new unsigned char[COPY_BUFFER_LENGTH];

size_t read_size = 0;

do

{

read_size = fread(buf, 1, COPY_BUFFER_LENGTH, fSrc);

if (read_size != 0)

{

fwrite(buf, 1, read_size, fDes);

}

} while (read_size == COPY_BUFFER_LENGTH);

  

rsp["rsp"] = "success";

fclose(fSrc);

fclose(fDes);

delete[] buf;

return 0;

}

```

  

> Note: `#include <errno.h>`,可以使用strerror(errno)查看错误信息。

  

http://wiki.vd.sec.samsung.net/pages/viewpage.action?spaceKey=vdproductsecurity&title=Access+Control+Training+Material

第二个ppt的16页，里面有说明进程间共享的目录。

  

之前能访问/opt/media可能是因为 mdeservice是 systemd启动的。

  

systemd启动的进程不受amd管理，因此没有appid但是也没有权限问题。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3NDE3MTIyMjVdfQ==
-->